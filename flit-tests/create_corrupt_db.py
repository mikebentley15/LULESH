#!/usr/bin/env python3

import corrupt_clang

from argparse import ArgumentParser
from collections import namedtuple
import csv
import itertools
import os
import random
import subprocess as subp
import sys
import tempfile

def parse_args(arguments):
    'Parse arguments and returned the parsed product'
    parser = ArgumentParser()
    parser.add_argument('procfiles', metavar='ProcFile', nargs='+',
                        help='''
                            The .proc files generated by the corrupt clang
                            compiler when in --capture-choices mode.  This is
                            the set of files where the random choices will be
                            made.
                            ''')
    parser.add_argument('-n', '--number', type=int, default=1000,
                        help='''
                            Number of corruption choices to make.  The default
                            is to make 1000 of them.
                            ''')
    parser.add_argument('-a', '--all', action='store_true',
                        help='''
                            Generate a corruption choice for all floating-point
                            locations given by the procfiles.  This is
                            tractable when the number of floating-point
                            locations is not too large (such as 1000).  This is
                            in opposition to the --number flag.
                            ''')
    parser.add_argument('--all-ops', action='store_true',
                        help='''
                            Generate four corruption choices for each file
                            location, one for each of the four different types
                            of operations (ADD, SUB, MUL, DIV).  This is only
                            applicable with the --all flag.
                            ''')
    parser.add_argument('-o', '--output', default='corruptions.sqlite',
                        help='''
                            The name of the sqlite file to use.  The default is
                            'corruptions.sqlite'.
                            ''')
    parser.add_argument('-s', '--seed', default=42,
                        help='''
                            The seed for the random number generator.  The
                            default is 42.
                            ''')
    parser.add_argument('-t', '--test', required=True,
                        help='''
                            The test case name to attribute the corruption.
                            ''')
    return parser.parse_args(arguments)

def choose_injection(function_tuples, choice_num=None, op=None, val=None):
    '''
    Chooses a site to inject and returns a ChoiceTuple object

    @param function_tuples: a list of FunctionTuple objects from
        parse_captured()
    @param choice_num: if given, specifies a static choice_num to use,
        otherwise, will choose randomly between [1, total_choice_count]
    @param op: if given, specifies a static op to use
    @param val: if given, specifies a static val to use

    @return an InjectionChoiceTuple object with the following attributes:
        - fname: filepath
        - func: function name
        - instr: instruction number to corrupt in func
        - op: operation to use, one of ('ADD', 'SUB', 'DIV', 'MUL')
        - val: value to inject
    '''
    InjectionChoiceTuple = namedtuple('InjectionChoiceTuple',
                                      'fname, func, instr, op, val')
    total_instructions = sum(x.instr_count for x in function_tuples)
    if choice_num is not None or choice_num <= 0 or choice_num > total_instructions:
        choice_num = random.randint(1, total_instructions)
    if op not in ('ADD', 'SUB', 'DIV', 'MUL'):
        op = random.choice(('ADD', 'SUB', 'DIV', 'MUL'))
    if val is None:
        val = random.random()
        if op in ('ADD', 'SUB'):
            val *= 1e-4
    for function in function_tuples:
        if choice_num <= function.instr_count:
            return InjectionChoiceTuple(function.file, function.function,
                                        choice_num, op, val)
        else:
            choice_num -= function.instr_count
    return None

def main(arguments):
    'Main logic here'
    args = parse_args(arguments)
    random.seed(args.seed)
    corrupt_clang.random.seed(args.seed)
    
    functions = corrupt_clang.parse_captured(args.procfiles)
    choices = set()
    choices_set = set()
    choices = []
    total_instructions = sum(x.instr_count for x in functions)

    if args.all:
        ops = [None]
        if args.all_ops:
            ops = ('ADD', 'SUB', 'MUL', 'DIV')
        for i, op in itertools.product(range(total_instructions), ops):
            choice = choose_injection(functions, choice_num=i+1, op=op)
            choices.append(
                '{x.fname},{x.func},{x.instr},{x.val},{x.op}'.format(x=choice))
            assert choice not in choices_set, choice
            choices_set.add(choice)
    else:
        while len(choices) < args.number:
            choice = choose_injection(functions)
            if choice not in choices_set:
                choices.append(
                    '{x.fname},{x.func},{x.instr},{x.val},{x.op}'.format(x=choice))
                choices_set.add(choice)

    # create the CSV file containing the results to use
    with tempfile.NamedTemporaryFile(suffix='.csv', mode='w') as fout:
        writer = csv.writer(fout)
        # header row
        writer.writerow([
            'name',
            'host',
            'compiler',
            'optl',
            'switches',
            'precision',
            'score_hex',
            'score',
            'resultfile',
            'comparison_hex',
            'comparison',
            'file',
            'nanosec',
            ])
        for i, choice in enumerate(choices):
            writer.writerow([
                args.test,                        # 'name',
                'ray',                            # 'host',
                './corrupt_clang.py',             # 'compiler',
                '-O2',                            # 'optl',
                '--corrupt {}'.format(choice),    # 'switches',
                'd',                              # 'precision',
                '0x3ffbccccccccccccd000',         # 'score_hex',
                '0.1000000000000000055511151231257827021181583404541015625',
                                                  # 'score',
                'NULL',                           # 'resultfile',
                '0x3ffbccccccccccccd000',         # 'comparison_hex',
                '0.1000000000000000055511151231257827021181583404541015625',
                                                  # 'comparison',
                'executable_name',                # 'file',
                '0',                              # 'nanosec',
                ])
        fout.flush()

        subp.check_call(['flit', 'import',
                         '--dbfile', args.output,
                         fout.name])

if __name__ == '__main__':
    main(sys.argv[1:])
