#!/usr/bin/env python3
'''
Wraps around the fpinjector version of clang++ to make the injecting and random
choosing of injection easy.  Use this script as your compiler with the extra
options, as can be seen from passing --help to this script.
'''

from argparse import ArgumentParser
from collections import namedtuple
import os
import random
import subprocess as subp
import sys


CXX = '/collab/usr/global/tools/pruners/blueos_3_ppc64le_ib/fpinjector-0.0.1' \
      '/llvm-7.0-08152018/install/bin/clang++'
assert os.path.isfile(CXX)

CXXFLAGS = [
    '-Xclang',
    '-load',
    '-Xclang',
    '/collab/usr/global/tools/pruners/blueos_3_ppc64le_ib/fpinjector-0.0.1'
    '/lib/libinjector.so',
    ]
assert os.path.isfile(CXXFLAGS[-1])

def print_usage(progname=sys.argv[0]):
    'Prints usage information to the console'
    print(
        'Usage:\n'
        '  {} [options] [--] <clang arguments> ...\n'.format(progname) +
        '\n'
        'Description:\n'
        '  A wrapper around a clang compiler that has an added pass that can\n'
        '  corrupt a floating-point computation inside of a compilation.\n'
        '  This clang compiler is found at:\n'
        '    {}\n'.format(CXX) +
        '\n'
        'Options:\n'
        '  -h, --help           Print this usage and exit.\n'
        '\n'
        '  --                   Finish parsing by the script and pass the\n'
        '                       remaining arguments to clang.\n'
        '\n'
        '  One of the following arguments must be present:\n'
        '\n'
        '  --capture-choices    Captures all possible corruption locations\n'
        '                       for the given file to compile.  This list\n'
        '                       of possible corruption locations will be\n'
        '                       output to <file>.prof for the file passed\n'
        '                       to clang.  This needs to be done before any\n'
        '                       corruptions can be chosen (using the\n'
        '                       --choose-corruption flag).\n'
        '\n'
        '  --choose-corruption <all-files>\n'
        '                       Chooses a file to corrupt, and from that\n'
        '                       file, chooses the location to corrupt (from\n'
        '                       the <file>.prof generated by\n'
        '                       --capture-choices).  This will then output\n'
        '                       to the console the chosen corruption as a\n'
        '                       comma-separated string, ready to be passed\n'
        '                       into the --corrupt flag.\n'
        '\n'
        '                       Note that with this option, the clang\n'
        '                       compiler will not be executed.\n'
        '\n'
        '  --corrupt <corruption-string>\n'
        '                       Tells this special clang compiler to corrupt\n'
        '                       the specified location in the specified way.\n'
        '                       The corruption string is of the following\n'
        '                       format:\n'
        '                       <file>,<function>,<instruction>,<value>,<op>\n'
        '                       - file: file to corrupt\n'
        '                       - function: mangled name of function symbol\n'
        '                       - instruction: number inside of function\n'
        '                       - value: value to inject\n'
        '                       - op: operation to inject, one of\n'
        '                         ("ADD", "SUB", "MUL", "DIV")\n'
        '\n'
        )

def parse_args(arguments):
    '''
    Parses arguments relevant to this script and returns the parsed arguments
    as well as the remaining arguments to be passed along.

    Returns a namespace object with the following attributes:
    - mode: one of ('capture', 'choose', 'corrupt')
    If mode == 'choose', then
    - files: the list of files to choose from for corruption
    The rest are only used if mode == 'corrupt'
    - file: the file to corrupt
    - function: the function to corrupt (mangled name)
    - instruction: the instruction number to corrupt
    - value: a floating point value to use in the corruption
    - op: the type of corruption, one of ('ADD', 'SUB', 'MUL', 'DIV')

    @return (parsed_args, remaining_args)
      parsed_args: is a Namespace object with the attributes described above
      remaining_args: unparsed arguments that are to be passed on to the
        compiler
    '''
    #print('parsing: {}'.format(arguments))
    remaining = list(arguments)
    # Create an empty namespace.  We will populate ourselves
    parsed = ArgumentParser().parse_args(args=[])
    parsed.mode = None
    parsed.files = None
    parsed.file = None
    parsed.function = None
    parsed.instruction = None
    parsed.value = None
    parsed.op = None

    valid_modes = ('capture', 'choose', 'corrupt')
    valid_ops = ('ADD', 'SUB', 'MUL', 'DIV')

    while len(remaining) > 0:
        arg = remaining.pop(0)
        if arg == '-h' or arg == '--help':
            print_usage()
            sys.exit(0)
        elif arg == '--capture-choices':
            parsed.mode = 'capture'
        elif arg == '--choose-corruption':
            parsed.mode = 'choose'
            parsed.files = remaining
            remaining = []
        elif arg == '--corrupt':
            parsed.mode = 'corrupt'
            corrupt_split = remaining.pop(0).split(',')
            parsed.file = corrupt_split[0]
            parsed.function = corrupt_split[1]
            parsed.instruction = int(corrupt_split[2])
            parsed.value = float(corrupt_split[3])
            parsed.op = corrupt_split[4]
        elif arg == '--':
            # means stop parsing
            break
        else:
            # not recognized, keep the arg and finish
            remaining.insert(0, arg)
            break

    # check command-line parsing
    assert parsed.mode in valid_modes, 'Invalid mode: {}'.format(parsed)
    if parsed.mode == 'choose':
        assert isinstance(parsed.files, list)
        assert len(parsed.files) > 0, 'Must provide at least one file to choose'
        for f in parsed.files:
            assert isinstance(f, str)
            assert os.path.isfile(f), 'File does not exist: {}'.format(f)
            fp = f + '.prof'
            assert os.path.isfile(fp), 'File does not exist: {}'.format(fp)
    if parsed.mode == 'corrupt':
        assert isinstance(parsed.file, str)
        assert os.path.isfile(parsed.file), \
            'File does not exist: {}'.format(parsed.file)
        assert isinstance(parsed.function, str)
        assert isinstance(parsed.instruction, int)
        assert parsed.instruction >= 0
        assert isinstance(parsed.value, float)
        assert parsed.op in valid_ops

    return (parsed, remaining)

def parse_captured(prof_files):
    '''
    Parses the captured profiles with floating-point ops.

    @param prof_files: a list of profile files generated by the
        --capture-choices flag

    @return list of FunctionTuple with the following attributes:
        - file: filepath
        - function: function name
        - instr_count: number of floating-point operations in the function
    '''
    FunctionTuple = namedtuple('FunctionTuple', 'file, function, instr_count')
    funcs = []
    for prof in prof_files:
        fname = prof[:-len('.prof')]
        with open(prof, 'r') as fin:
            function = None
            count = None
            for line in fin:
                if not line.startswith('\t'):
                    if function is not None:
                        funcs.append(FunctionTuple(fname, function, count))
                    function = line[:-2]
                    count = 0
                else:
                    count += 1
        if function is not None:
            funcs.append(FunctionTuple(fname, function, count))
    return funcs

def choose_injection(function_tuples):
    '''
    Chooses a site to inject and returns a ChoiceTuple object

    @param function_tuples: a list of FunctionTuple objects from
        parse_captured()

    @return an InjectionChoiceTuple object with the following attributes:
        - fname: filepath
        - func: function name
        - instr: instruction number to corrupt in func
        - op: operation to use, one of ('ADD', 'SUB', 'DIV', 'MUL')
        - val: value to inject
    '''
    InjectionChoiceTuple = namedtuple('InjectionChoiceTuple',
                                      'fname, func, instr, op, val')
    total_instructions = sum(x.instr_count for x in function_tuples)
    choice_num = random.randint(1, total_instructions)
    op = random.choice(('ADD', 'SUB', 'DIV', 'MUL'))
    val = random.random()
    if op in ('ADD', 'SUB'):
        val *= 1e-4
    for function in function_tuples:
        if choice_num <= function.instr_count:
            return InjectionChoiceTuple(function.file, function.function,
                                        choice_num, op, val)
        else:
            choice_num -= function.instr_count
    return None

def main(arguments):
    'Main logic here'
    parsed, remaining = parse_args(arguments)
    #print('parsed = {}'.format(parsed))
    #print('remaining = {}'.format(remaining))

    env = os.environ.copy()
    if parsed.mode == 'capture':
        env['INJECTOR_PROFILE'] = '1'
    elif parsed.mode == 'corrupt':
        env['INJECTOR_ON'] = '1'
        env['INJECTOR_MODULE'] = parsed.file
        env['INJECTOR_FUNCTION'] = parsed.function
        env['INJECTOR_INSTRUCTION_ID'] = str(parsed.instruction)
        env['INJECTOR_VALUE'] = str(parsed.value)
        env['INJECTOR_OP'] = parsed.op

    if parsed.mode in ('capture', 'corrupt'):
        subp.check_call([CXX] + CXXFLAGS + remaining, env=env)
    elif parsed.mode == 'choose':
        functions = parse_captured(x + '.prof' for x in parsed.files)
        chosen = choose_injection(functions)
        print('{x.fname},{x.func},{x.instr},{x.val},{x.op}'.format(x=chosen))
    else:
        raise RuntimeError('Unsupported mode: {}'.format(parsed.mode))

if __name__ == '__main__':
    main(sys.argv[1:])
